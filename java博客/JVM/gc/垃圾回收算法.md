#### 标记-清除算法 （Marking - Sweep）

> 算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。
>
> 缺点：
>
> * 效率问题，标记和清理两个过程效率都不高。因为需要扫描所有对象。堆越大，GC 越慢。
> * 空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾收集动作。并且 GC 次数越多，碎片越严重。

***



#### 复制收集算法（Copying）

> ​		将可用内存划分为两块，每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面，然后就把原来的整块内存一次性清理掉。
>
> 优点：
>
> ​		这样使得内存回收都是对整个半区的回收，内存分配也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。
>
> 缺点：
>
> ​		只是这种算法的代价是将内存缩小为原来的一半，代价高昂。如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。
>
> 根据IBM的专门研究，98% 的Java对象只会存活 1个GC 周期，对这些对象很适合用复制算法。而且不用 1：1 的划分工作区和复制区的空间。



现在的商业虚拟机中都是用了这一种收集算法来回收新生代。

将内存分为一块较大的 eden 空间和 2 块较少的 survivor 空间，每次使用 eden 和其中一块 survivor，当回收时将 eden 和 survivor 还存活的对象一次性拷贝到另外一块 survivor 空间上，然后清理掉 eden 和用过的 survivor。

Oracle HotSpot 虚拟机默认 eden 和 survivor 的大小比例是 8：1。也就是每次只有 10% 的内存是“浪费的”。

***



#### 标记-整理算法 （Mark-Compact）

> ​		标记过程仍然和上面标记一样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存。
>
> 优缺点：
>
> 没有内存碎片。比Mark-sweep  耗费更多的时间进行 compact。

***



#### 分代算法（Generational）

> 当前商业虚拟机的垃圾收集都是采用“分代收集”算法，根据对象不同的存活周期将内存划分为几块
>
> ​		一般是把Java堆分作新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集 算法，譬如新生代每次 GC 都有大批对象死去，只有少量存活，那就选用复制算法只需付出少量存活对象的复制成本就可以完成收集。对于老年代，就可以使用标记-整理算法 或者标记清除算法。



##### 年轻代：

* 新生成的对象都放在新生代。年轻代用复制算法进行 GC（理论上，年轻代对象的生命周期非常短，所有适合复制算法）

* 年轻代分为三个区。一个 Eden 区，两个 Survivor 区（可以通过设置参数设置 Survivor 个数）。对象在 Eden 区中生成。当Eden去满了，会经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（**这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生**）。2个Survivor是完全对称，轮流替换。

  **永远有一个survivor space是空的，另一个非空的survivor space无碎片**。

* Eden 和 2个Survivor的缺省比例是 8：1：1，也就是10% 的空间会被浪费。可根据GC log 的信息调整大小的比例。



##### 老年代：

* 存放了经过一次或多次 GC 还存活的对象
* 一般进行 Mark-Sweep或者Mark-Compact 算法进行GC
* 有多种垃圾收集器可以选择。每种收集器可以看做一个GC算法的具体实现。可以根据具体应用的需求选用最合适的垃圾收集器。



年轻代触发的 gc 是 minor gc 不会导致应用进程停顿
而老年代触发的 gc 是 full gc 会导致应用进程停顿 对性能的影响比较大

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )