现代JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。

所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该命令。

所谓编译执行，就是通过即使编译器（Just In Time，JIT）将字节码转换为本地机器码来执行；现代JVM会根据代码热点（即代码使用的频率）来生成相应的本地机器码。



##### 基于栈的指令集和基于寄存器的指令集之间的关系：

1、JVM执行指令时所采取得就是基于栈的指令集。

2、基于栈的指令集主要的操作。

3、基于栈的指令集优势在于移植性好，而基于寄存器的指令集是与硬件精密关联的，无法做到可移植性。

4、基于栈的指令集的缺点在于完成相同的操作，指令数量要比基于寄存器的指令集数量要多；基于站的指令集是    在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机可以采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。



##### 实例分析：

```java
public class MyTest9 {
    public int myCalculate(){
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;

        int result = (a + b - c) * d;

        return result;
    }
}
```

字节码：

```java
 0 iconst_1  //将1推送至操作数栈中
 1 istore_1  // 弹出操作数栈顶元素（这里是1），然后赋值给局部变量表第一项。因为局部变量第0项是this
 2 iconst_2
 3 istore_2
 4 iconst_3
 5 istore_3
 6 iconst_4
 7 istore 4
 9 iload_1   //  将局部变量表的第一项推送至栈顶
10 iload_2  // 将局部变量表的第二项推送至栈顶,这时候栈里面有1，2
11 iadd   // 弹出栈顶的前两个元素，并且相加，然后把结果压入栈.即弹出1，2，相加结果为3，再压入栈
12 iload_3 //
13 isub
14 iload 4
16 imul
17 istore 5   // 弹出栈顶元素，赋值给局部变量第5项，即result变为5
19 iload 5  
21 ireturn // 返回栈顶元素到调用此方法的那个方法的操作数栈中。其他的栈内元素会被丢弃。
```

iconst_1 可以用 bipush<1>代替，iconst 只是预先义好了5个数（1~5）



ireturn的理解：

在A方法里面调用了B方法，执行到B方法这行代码时，会去执行B方法，然后B通过ireturn返回结果到A方法操作数栈当中。